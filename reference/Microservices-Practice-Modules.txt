Module Summary Notes practice
===============================

Module 1: Main Microservices Architecture and tools needed
   

Module 3:  Create microservice -> employee-service 
        1) https://start.spring.io/ ( Spring initializr )
          - Web/JPA/H2/Config-client/actuator/devtools
          - Update Pom for boot and cloud version compatibility
             Spring boot starter - 1.5.2.Release
             Spring cloud        - Dalston.RELEASE
     
        2) @RestController / @GetMapping / @PathVariable
           Controller and Model class --EmployeeController & Employee
           
        3) - Use JPA and mark the Model ans entity Bean
              @Entity
              @Column(name="column_name) / @Id
              constructor with fields + default constructor
           
           - Create an Interface - Employee Repository
             public interface EmployeeRepository extends JpaRepository<Employee,Long> {}
               Long represents the ID Field of the Entity
               JpaRepository provides CRUD implementations
           
           - @GetMapping("/employee/{empId}")
	             public Employee getEployeeDetails(@PathVariable Long empId)
	                {
	                	return employeeRepository.findOne(empId); 
	                }
        4) data.sql with insert query to load into H2 DB
            insert into employee (emp_id,first_name,last_name,date_of_joining) values (101,'F001','L001',sysdate());

           
     
Module 4: Create microservice -> role-service
             - RoleRepository custom findByroleName()
               public Role findByRoleName(String roleName);
	       
	     - http://localhost:8061/h2-console
                jdbc:h2:mem:testdb
      
Module 5: Create composite microservice -> payroll-service
           - insert to payroll table with if valid employee and role fetched
	   - Payroll Model also has payrollId
	 4)  - Rest Templates.
	     - payroll ID marked as @GeneratedValue
	     - employee service and role service are called using the RestTemplate.getForEntity()
               ( important to kee same naming comvention in the payroll Entity to create right mapping )
               So payroll Entity is close to the role and employee entity attribute naming wise.
               ======================
	        ResponseEntity<Payroll> forEmpEntity = new RestTemplate().getForEntity(
				"http://localhost:8060/employee/{empId}",Payroll.class,empId);
		Payroll empPayroll = forEmpEntity.getBody();
		
		ResponseEntity<Payroll> forRoleEntity = new RestTemplate().getForEntity(
				"http://localhost:8061/role/{roleName}",Payroll.class,roleName);
		
		empPayroll.setRoleId(forRoleEntity.getBody().getRoleId());
		empPayroll.setRoleName(forRoleEntity.getBody().getRoleName());
		empPayroll.setRoleDescription(forRoleEntity.getBody().getRoleDescription());
		payrollRepository.save(empPayroll);
               =======================
	   
	   
Module 6: FEIGN Template ( Netflix ) Rest API calls
         Feign integrates with Ribbon and Eureka

        i) add spring dependency in pom :
           <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-starter-feign</artifactId>

        ii) Update BootMain Application with 
             @EnableFeignClients("com.ansa.payroll")  // package to scan for feign clients

	iii) Make a Feign Client Interface - which will replace the Rest Template
             
             @FeignClient(name="employee-service",url="http://localhost:8060")
             public interface EmployeeServiceFeignTemplate {
		@GetMapping("/employee/{empId}")
	        public Payroll getEmployeeDetails(@PathVariable("empId") Long empId);
                }
             ** note the @PathVariable("empId")
             ** note the return type is an TransferBeanType Entity similar to employee Entity
                  Payroll Entity has all same attributes as Employee Entity ( same naming of variables )
   
Module 6: RIBBON for Load balancing
Module 7: EUREKA for Naming Discovery Servier
Module 8: ZUUL API Gateway
          SLEUTH - How API gateway can also provide cross-cutting functionalities like Logging filters ( pre )
Module 9: ZIPKIN server for Distributed Tracing
          SLEUTH - SERVICE_NAME,SPANID,CORRELATIONID,false
Module 10: HYSTRIX for Fault tolerance
Module 11: Spring Cloud Config Server
           Spring Cloud BUS

           
           
           
           Order of Spawning the Microservices for all purposes
 1. EUREKA Discovery Naming Server
 2. Zuul - API Gateway Server
 3. SpringCloud ConfigServer
 4. ZIPKIN - Log Tracing Server
 
