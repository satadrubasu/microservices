Module Summary Notes practice
===============================

Module 1: Main Microservices Architecture and tools needed
   

Module 3:  Create microservice -> employee-service 
        1) https://start.spring.io/ ( Spring initializr )
          - Web/JPA/H2/Config-client/actuator/devtools
          - Update Pom for boot and cloud version compatibility
             Spring boot starter - 1.5.2.Release
             Spring cloud        - Dalston.RELEASE
     
        2) @RestController / @GetMapping / @PathVariable
           Controller and Model class --EmployeeController & Employee
           
        3) - Use JPA and mark the Model ans entity Bean
              @Entity
              @Column(name="column_name) / @Id
              constructor with fields + default constructor
           
           - Create an Interface - Employee Repository
             public interface EmployeeRepository extends JpaRepository<Employee,Long> {}
               Long represents the ID Field of the Entity
               JpaRepository provides CRUD implementations
           
           - @GetMapping("/employee/{empId}")
	             public Employee getEployeeDetails(@PathVariable Long empId)
	                {
	                	return employeeRepository.findOne(empId); 
	                }
        4) data.sql with insert query to load into H2 DB
            insert into employee (emp_id,first_name,last_name,date_of_joining) values (101,'F001','L001',sysdate());

           
     
Module 4: Create microservice -> role-service
             - RoleRepository custom findByroleName()
               public Role findByRoleName(String roleName);
	       
	     - http://localhost:8061/h2-console
                jdbc:h2:mem:testdb
      
Module 5: Create composite microservice -> payroll-service
           - insert to payroll table with if valid employee and role fetched
	   - Payroll Model also has payrollId
	 4)  - Rest Templates.
	     - payroll ID marked as @GeneratedValue
	     - employee service and role service are called using the RestTemplate.getForEntity()
               ( important to kee same naming comvention in the payroll Entity to create right mapping )
               So payroll Entity is close to the role and employee entity attribute naming wise.
               ======================
	        ResponseEntity<Payroll> forEmpEntity = new RestTemplate().getForEntity(
				"http://localhost:8060/employee/{empId}",Payroll.class,empId);
		Payroll empPayroll = forEmpEntity.getBody();
		
		ResponseEntity<Payroll> forRoleEntity = new RestTemplate().getForEntity(
				"http://localhost:8061/role/{roleName}",Payroll.class,roleName);
		
		empPayroll.setRoleId(forRoleEntity.getBody().getRoleId());
		empPayroll.setRoleName(forRoleEntity.getBody().getRoleName());
		empPayroll.setRoleDescription(forRoleEntity.getBody().getRoleDescription());
		payrollRepository.save(empPayroll);
               =======================
	   
	   
Module 6: FEIGN Template ( Netflix ) Rest API calls
         Feign integrates with Ribbon and Eureka

        i) add spring dependency in pom :
           <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-starter-feign</artifactId>

        ii) Update BootMain Application with 
             @EnableFeignClients("com.ansa.payroll")  // package to scan for feign clients

	iii) Make a Feign Client Interface - which will replace the Rest Template
             
             @FeignClient(name="employee-service",url="http://localhost:8060")
             public interface EmployeeServiceFeignTemplate {
		@GetMapping("/employee/{empId}")
	        public Payroll getEmployeeDetails(@PathVariable("empId") Long empId);
                }
             ** note the @PathVariable("empId")
             ** note the return type is an TransferBeanType Entity similar to employee Entity
                  Payroll Entity has all same attributes as Employee Entity ( same naming of variables )
   
Module 7: RIBBON for **CLIENT SIDE** Load balancing
          RIBBON cannot pick dynamic servers which are active/inactive -Eureka solves in next mod
          Say 2 instances of employee-Service , we dont need to hardcode the host in the 
           @FeignClient(name="employee-service",url="http://localhost:8060") -- this will now change
	   
	   i) pom dependency addition
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-ribbon</artifactId>
	   
           ii) Feign Client change
               @FeignClient(name="employee-service") // no more URL
               @RibbonClient(name="employee-service")
	       public interface EmployeeServiceFeignClient {
        
	   iii) application.properties ( list of servers)
                employee-service.ribbon.listOfServers=http://localhost:8060,http://localhost:8160
		role-service.ribbon.listOfServers=http://localhost:8061,http://localhost:8161
		
          iv) a) for Employee entity add port as an attribute
              b) for Payroll entity add port as an attribute ( so it maps to employee while fetching value)
	      c) in data.sql add port as a column
              d) Update the PayrollController to return type Long to capture port number instead of void for the POST
	      e) For instances of employeeServiceController
                   @Autowired
                   Environment env;
                   .. empResponse.setPort(env.getProperty("local.server.port"));
		      

Module 8: EUREKA - Naming Discovery Server
          i) spring initialzr -> eureka-server,actuator,devtool,config client
	  ii) Update spring boot version ( 1.5.2.RELEASE ) / Spring cloud (Dalston.RELEASE)
               version artifact name is: ( not the netflix version in Dalston )
                 <artifactId>spring-cloud-starter-eureka-server</artifactId>
		 
          iv) application.properties
             spring.application.name=eureka-server
             server.port=8050
	     eureka.client.register-with-eureka=false  // dont register server with itself as a client ( boot app )
	     eureka.client.fetch-registry=false
	     
	  v) @EnableEurekaServer in spring boot main class
	  
	  vi) CLIENT SIDE CONFIGURATION to register to eureka
	     a) Client boot app update pom:
                <artifactId>spring-cloud-starter-eureka</artifactId>
             b) Register Client Spring boot main app to Eureka Server
                @EnableDiscoveryClient in the main class
		
             c) application.properties
                 eureka.client.service-url.default-zone= http://localhost:8050/eureka
		 
                 also we no longer nee to keep the 
                   role-service.ribbon.list-of-servers  etc can be eliminated
                  Ribbon CLinet is integrated with eureka server to fetch services based of the service name.

Module 8: ZUUL API Gateway
          SLEUTH - How API gateway can also provide cross-cutting functionalities like Logging filters ( pre )
Module 9: ZIPKIN server for Distributed Tracing
          SLEUTH - SERVICE_NAME,SPANID,CORRELATIONID,false
Module 10: HYSTRIX for Fault tolerance
Module 11: Spring Cloud Config Server
           Spring Cloud BUS

           
           
           
           Order of Spawning the Microservices for all purposes
 1. EUREKA Discovery Naming Server
 2. Zuul - API Gateway Server
 3. SpringCloud ConfigServer
 4. ZIPKIN - Log Tracing Server
 
